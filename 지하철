#include <iostream>
#include <vector>
#include <map>
#include <queue>
#include <string>
#include <algorithm>
using namespace std;

map<string, vector<string>> graph;
map<string, vector<string>> stationToLines;

void addEdge(const string& a, const string& b) {
    graph[a].push_back(b);
    graph[b].push_back(a);
}

void addLine(const string& lineName, const vector<string>& stations) {
    for (size_t i = 0; i + 1 < stations.size(); ++i) {
        addEdge(stations[i], stations[i + 1]);
    }
    for (const string& station : stations) {
        stationToLines[station].push_back(lineName);
    }
}

int bfs(const string& start, const string& end, map<string, string>& parent) {
    if (graph.find(start) == graph.end() || graph.find(end) == graph.end()) {
        return -1;
    }

    map<string, bool> visited;
    map<string, int> dist;
    queue<string> q;

    visited[start] = true;
    dist[start] = 0;
    parent[start] = "";
    q.push(start);

    while (!q.empty()) {
        string cur = q.front(); q.pop();
        if (cur == end) return dist[cur];
        for (const string& nxt : graph[cur]) {
            if (!visited[nxt]) {
                visited[nxt] = true;
                dist[nxt] = dist[cur] + 1;
                parent[nxt] = cur;
                q.push(nxt);
            }
        }
    }
    return -1;
}

vector<string> reconstructPath(const string& start, const string& end, const map<string, string>& parent) {
    vector<string> path;
    string cur = end;
    while (cur != "") {
        path.push_back(cur);
        auto it = parent.find(cur);
        if (it == parent.end()) break;
        cur = it->second;
    }
    reverse(path.begin(), path.end());
    return path;
}

void buildGraph() {
    addLine("1호선", {
        "노포", "범어사", "남산", "두실", "구서", "장전", "부산대", "온천장",
        "동래", "교대", "연산", "시청", "양정", "부전", "서면", "범내골", "범일",
        "좌천", "부산진", "초량", "부산역", "중앙", "남포", "자갈치", "토성",
        "동대신", "서대신", "대티", "괴정", "사하", "당리", "하단", "신평",
        "동매", "신장림", "낫개", "다대포항", "다대포해수욕장"
        });

    addLine("2호선", {
        "장산", "중동", "해운대", "동백", "벡스코", "센텀시티", "민락", "수영",
        "광안", "금련산", "남천", "경성대_부경대", "대연", "못골", "지게골",
        "문현", "국제금융센터_부산은행", "전포", "서면", "부암", "가야", "동의대",
        "개금", "냉정", "주례", "감전", "사상", "덕포", "모덕", "모라", "구남",
        "구명", "덕천", "수정", "화명", "율리", "동원", "금곡", "호포", "중산",
        "부산대양산캠퍼스", "남양산", "양산"
        });

    addLine("3호선", {
        "수영", "망미", "배산", "물만골", "연산", "거제", "종합운동장", "사직",
        "미남", "만덕", "남산정", "숙동", "덕천", "구포", "강서구청", "체육공원", "대저"
        });

    addLine("4호선", {
        "미남", "동래", "수안", "낙민", "충렬사", "명장", "서동", "금사",
        "반여농산물시장", "석대", "영산대", "윗반송", "고촌", "안평"
        });

    addLine("동해선", {
        "부전", "거제해맞이", "거제", "교대", "동래", "안락", "부산원동", "재송",
        "센텀", "벡스코", "신해운대", "송정", "오시리아", "기장", "일광", "좌천",
        "월내", "서생", "남창", "망양", "덕하", "개운포", "태화강"
        });

    addLine("부산김해경전철", {
        "가야대", "장신대", "연지공원", "박물관", "수로왕릉", "봉황", "부원", "김해시청",
        "인제대", "김해대학", "지내", "불암", "대사", "평강", "대저", "등구", "덕두",
        "공항", "서부산유통지구", "괘법르네시떼", "사상"
        });
}

int main() {
    buildGraph();

    string start, end;
    cout << "출발역: ";
    getline(cin, start);
    cout << "도착역: ";
    getline(cin, end);

    map<string, string> parent;
    int distance = bfs(start, end, parent);

    if (distance < 0) {
        cout << "출발역 또는 도착역이 존재하지 않거나 연결되어 있지 않습니다.\n";
        return 0;
    }

    cout << "\n출발역: " << start << "\n";
    cout << "도착역: " << end << "\n";
    cout << "총 정거장 수: " << distance << "\n";

    vector<string> path = reconstructPath(start, end, parent);
    cout << "경로:\n";

    string currentLine = "";
    for (size_t i = 0; i < path.size(); ++i) {
        string station = path[i];

        if (i == 0) {
            // 시작 역 - 첫 노선 설정
            if (!stationToLines[station].empty())
                currentLine = stationToLines[station][0];
            cout << station << " (" << currentLine << ")\n";
        }
        else {
            string prev = path[i - 1];
            string newLine = "";

            for (const string& line : stationToLines[station]) {
                if (find(stationToLines[prev].begin(), stationToLines[prev].end(), line) != stationToLines[prev].end()) {
                    newLine = line;
                    break;
                }
            }

            if (newLine != currentLine && !newLine.empty()) {
                cout << " ↳ [" << currentLine << " → " << newLine << "] 환승\n";
                currentLine = newLine;
            }

            cout << station << " (" << currentLine << ")\n";
        }
    }

    return 0;
}
